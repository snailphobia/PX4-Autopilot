import numpy as np
import sys


################################### DEFINES ####################################

width = 79
height = 52
fovx = 60
fovy = 40
angle_of_view = 45  # degrees
position = np.array([0, 0, 10]).reshape(3, 1)

############################ ORTHOGONAL CALCULATION ############################

transfs2 = [
    np.array([2/(width-1),0,0,0,2/(height-1),0,0,0,1]).reshape(3,3), # scale between 0 and 2
    np.array([1,0,-1,0,1,-1,0,0,1]).reshape(3,3), # translate between -1 and 1
    np.array([1,0,0,0,-1,0,0,0,1]).reshape(3,3), # flip y axis
    np.array([np.tan(np.radians(fovx/2)),0,0,0,np.tan(np.radians(fovy/2)),0,0,0,-1]).reshape(3,3), # scale to fov
    # rotation of angle_of_view on the yz axis
    np.array([[1, 0, 0],[0, np.cos(np.radians(angle_of_view)), -np.sin(np.radians(angle_of_view))],[0, np.sin(np.radians(angle_of_view)), np.cos(np.radians(angle_of_view))]])
]

def calc_vec(result):
    for mat in transfs2:
        result = np.dot(mat, result)
    return result


def calculate_vector(x, y):
    result = np.array([x, y, 1]).reshape(3, 1)
    for mat in transfs2:
        result = np.dot(mat, result)
    direction = result
    t = -position[2]/direction[2]
    return position + t*direction

############################## GENERATING SOURCE ###############################

values = []
for x in range(0, width):
    for y in range(0, height):
        values.append((x, y))


norm = [[f"{float(calculate_vector(x, y)[0]):.2f}" for y in range(0, height) ] for x in range(0, width)]

arr = [f"{{{', '.join(v)}}}" for v in norm]
arry = [f"{float(calculate_vector(0, y)[1]):.2f}" for y in range(0, height)]
blackmagic = f"""/*  File autogenerated by src/examples/nxpcup/ortho.py
    Edits on this header are likely to be overwritten so beware */

#define PIXY_VEC_WIDTH {width}
#define PIXY_VEC_HEIGHT {height}



float orthoX[PIXY_VEC_WIDTH / 2][PIXY_VEC_HEIGHT] = {{
	{''',
	'''.join(arr[width//2+1:])}
}};

float orthoY[PIXY_VEC_HEIGHT] = {{
	{', '.join(arry)}
}};

void projection_to_plane(int x, int y, float *xf, float *yf) {{
	if(x < PIXY_VEC_WIDTH/2) {{
		*xf = -orthoX[PIXY_VEC_WIDTH/2 - x - 1][y];
	}} else if (x == PIXY_VEC_WIDTH/2 && PIXY_VEC_WIDTH % 2 == 1) {{
		*xf = 0;
	}} else {{
		*xf = orthoX[x - (PIXY_VEC_WIDTH/2+1)][y];
	}}
	*yf = orthoY[y];
}}

"""

print(blackmagic)
