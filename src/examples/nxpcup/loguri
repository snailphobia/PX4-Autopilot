	// int spion = 0;
// 	switch(current_state) {
// 		case NONE: {
// 			if (num_vectors == 0) {
// 				if (first_call) {
// 					no_line_time = hrt_absolute_time();
// 					first_call = false;
// 				} else {
// 					control.speed = SPEED_NORMAL;
// 					control.steer = last_steer;
// 					if (time_diff > 3000) {
// 						/* Stopping if no vector is available */
// 						control.steer = 0.0f;
// 						control.speed = SPEED_STOP;
// 					}
// 				}
// 				current_state = NONE;
// 			}
// 			if (num_vectors >= 1) {
// 				first_call = true;
// 				auto res = vecs[0];
// 				for (int i = 1; i < num_vectors; i++) {
// 					res = resulting_vector(res, vecs[i]);
// 				}
// 				float th1 = THRESHOLD_STRAIGHT;
// 				float th2 = THRESHOLD_STRAIGHT2;
// 				direction_e dir = get_direction(res);
// 				auto angle = atan2(res.m_y1 - res.m_y0, res.m_x1 - res.m_x0);
// 				if (dir != STRAIGHT) {
// 					control.speed = SPEED_SLOW;
// 					control.steer = dir == LEFT ? 1.0f : -1.0f;
// 					current_state = PREPARE_TURN;
// 				} else {
// 					control.speed = SPEED_NORMAL;
// 					control.steer = atan2(res.m_y1 - res.m_y0, res.m_x1 - res.m_x0);
// 					if (num_vectors >= 2)
// 						current_state = RECENTER;
// 					else
// 						current_state = STRAIGHT_LINE;
// 				}
// 			}
// 			break;
// 		}
// 		case PREPARE_TURN: {
// 			if (num_vectors == 0) {
// 				if (first_call) {
// 					no_line_time = hrt_absolute_time();
// 					first_call = false;
// 				} else {
// 					control.speed = SPEED_NORMAL;
// 					control.steer = last_steer;
// 					if (time_diff > 3000) {
// 						/* Stopping if no vector is available */
// 						control.steer = 0.0f;
// 						control.speed = SPEED_STOP;
// 					}
// 				}
// 			}
// 			if (num_vectors == 1) {
// CASE_PREP_TURN_ONE_VECTOR:;
// 				auto res = vecs[0];
// 				direction_e dir = get_direction(res);
// 				auto offset = one_vector_offset_from_center(res, frameWidth);
// 				if (dir == STRAIGHT) {
// 					// sanki, should not happen
// 				}
// 				if (dir == LEFT) {
// 					// close in to the right side of the track
// 					// if the vector is on the left, you will still go to the right until the right vector is visible
// 					if (offset < 0) {
// 						// vector is on the left, and signals to turn left
// 						// we can assume it is a crossroad, going straight
// 						// for now, until new input, which should occur shortly
// 						last_different_state = PREPARE_TURN;
// 						current_state = CROSSROAD;
// 						control.speed = SPEED_NORMAL;
// 						control.steer = STRAIGHT_;
// 					} else {
// 						if (should_turn(res)) {
// 							// we are going to turn LEFT, the vector is rightmost
// 							// we should turn start turning left
// 							last_different_state = PREPARE_TURN;
// 							current_state = TURN;
// 							control.steer = FULL_LEFT;
// 							control.speed = SPEED_SLOW;
// 						} else {
// 							// do not start turning yet
// 							// move alongside rightmost vector
// 							control.steer = (CAR_HALF_WIDTH - offset) / SCALING_FACTOR;
// 							// scale speed with amount of turning
// 							control.speed = SPEED_NORMAL * (1.f - abs(control.steer / 2.f));
// 						}
// 					}
// 				}
// 				// symmetrically for the right dir
// 				if (dir == RIGHT) {
// 					if (offset > 0) {
// 						// vector is on the right, and signals to turn right
// 						// we can assume it is a crossroad, going straight
// 						// for now, until new input, which should occur shortly
// 						last_different_state = PREPARE_TURN;
// 						current_state = CROSSROAD;
// 						control.speed = SPEED_NORMAL;
// 						control.steer = STRAIGHT_;
// 					} else {

// 						if (should_turn(res)) {
// 							// we are going to turn RIGHT, the vector is leftmost
// 							// we should start turning right
// 							last_different_state = PREPARE_TURN;
// 							current_state = TURN;
// 							control.steer = FULL_RIGHT;
// 							control.speed = SPEED_SLOW;
// 						} else {
// 							// do not start turning yet
// 							// move alongside leftmost vector
// 							control.steer = (CAR_HALF_WIDTH + offset) / SCALING_FACTOR;
// 							// scale speed with amount of turning
// 							control.speed = SPEED_NORMAL * (1.f - abs(control.steer / 2.f));
// 						}
// 					}
// 				}
// 			}
// 			if (num_vectors >= 2) {
// 				// select the most viable vector; the one that is opposite to the turn and starts as close to the camera as possible
// 				int selected = 0;
// 				// keep only the vectors that start from the bottom of the frame (discard the far away ones)
// 				int nb = 0, j = 0;
// 				Vector bottom[6];
// 				for (int i = 0; i < num_vectors; i++) {
// 					if (vecs[i].m_y0 > BOT)
// 						bottom[j++] = vecs[i];
// 				}
// 				nb = j;

// 				Vector res = bottom[0];
// 				for (int i = 1; i < nb; i++) {
// 					res = resulting_vector(res, bottom[i]);
// 				}
// 				direction_e dir = get_direction(res);

// 				if (dir == LEFT) {
// 					// select the rightmost vector
// 					for (int i = 1; i < nb; i++) {
// 						if (bottom[i].m_x0 > bottom[selected].m_x0 && bottom[i].m_x0 > frameWidth / 2)
// 							selected = i;
// 					}
// 				}
// 				if (dir == RIGHT) {
// 					// select the leftmost vector
// 					for (int i = 1; i < nb; i++) {
// 						if (bottom[i].m_x0 < bottom[selected].m_x0 && bottom[i].m_x0 < frameWidth / 2)
// 							selected = i;
// 					}
// 				}


// 				// vector is selected, keep only that one and discard the rest
// 				num_vectors = 1;
// 				vecs[0] = bottom[selected];
// 				goto CASE_PREP_TURN_ONE_VECTOR;
// 			}
// 			break;
// 		}
// 		case STRAIGHT_LINE: {
// 			if (num_vectors == 0) {
// 				last_different_state = STRAIGHT_LINE;
// 				current_state = NONE;
// 			}
// 			if (num_vectors == 1) {
// 				direction_e dir = get_direction(vecs[0]);
// 				if (dir == STRAIGHT) {
// 					control.speed = SPEED_NORMAL;
// 					control.steer = atan2(vecs[0].m_y1 - vecs[0].m_y0, vecs[0].m_x1 - vecs[0].m_x0);
// 				} else {
// 					last_different_state = STRAIGHT_LINE;
// 					current_state = PREPARE_TURN;
// 				}
// 			}
// 			if (num_vectors >= 2) {
// 				last_different_state = STRAIGHT_LINE;
// 				current_state = RECENTER;
// 			}
// 		}
// 		case CROSSROAD: {
// 			// slow down, and go straight, until further input
// 			// that contradicts this state:
// 			// there is at least a vector that is pointing to the left while being on the right side
// 			// or the other way around
// 			if (num_vectors == 0) {
// 				control.speed = SPEED_SLOW;
// 				continue;
// 			}
// 			if (num_vectors == 1) {
// 				direction_e dir = get_direction(vecs[0]);
// 				if (dir == STRAIGHT) {
// 					control.speed = SPEED_SLOW;
// 					control.steer = STRAIGHT_;
// 				} else {
// 					last_different_state = CROSSROAD;
// 					current_state = PREPARE_TURN;
// 				}
// 			}
// 			if (num_vectors >= 2) {
// 				last_different_state = CROSSROAD;
// 				current_state = RECENTER;
// 			}
// 		}
// 		case RECENTER: {

// 		}
// 	}

// 	switch (num_vectors) {
// 	case 0:{
// 		if(first_call){
// 			no_line_time = hrt_absolute_time();
// 			first_call = false;
// 		}else{
// 			time_diff = hrt_elapsed_time_atomic(&no_line_time);
// 			if(!spion) {
// 				control.steer = 2*last_steer;
// 				control.speed = 0.5f*last_speed;
// 				spion = 1;
// 			}

// 			if(time_diff > 10000){
// 				/* Stopping if no vector is available */
// 				control.steer = 0.0f;
// 				control.speed = SPEED_STOP;
// 			}
// 		}
// 		break;
// 	}
// 	case 2:{
// 		first_call = true;
// 		spion = 0;

// 		/* Very simple steering angle calculation, get average of the x of top two points and
// 		   find distance from center of frame */
// 		// main_vec.m_x1 = (vecs[0].m_x1 + vecs[1].m_x1) / 2;
// 		// control.steer = (float)(main_vec.m_x1 - window_center) / (float)frameWidth;
// 		int8_t resx = vecs[0].m_x1 - vecs[0].m_x0, res2x = vecs[1].m_x1 - vecs[1].m_x0;
// 		int8_t resy = vecs[0].m_y1 - vecs[0].m_y0, res2y = vecs[1].m_y1 - vecs[1].m_y0;
// 		VectorF vec1norn = {resx,resy};
// 		VectorF vec2norn = {res2x,res2y};
// 		VectorF avg = {(vec1norn.m_x0 + vec2norn.m_x0)/2,-((double)vec1norn.m_y0 + vec2norn.m_y0)/2.0};
// 		VectorF avgnorm = {avg.m_x0/(sqrt(avg.m_x0*avg.m_x0 + avg.m_y0*avg.m_y0)),avg.m_y0/(sqrt(avg.m_x0*avg.m_x0 + avg.m_y0*avg.m_y0))};

// 		// angle between avg and oy

// 		steers[steer_index] = avgnorm.m_x0;
// 		// float f = resx / (sqrt(resy * resy + resx * resx));
// 		// float f2 = res2x / (sqrt(res2y * res2y + res2x * res2x));
// 		// float angle = (acos(f) + acos(f2))/2 - M_PI;
// 		// float medcos = cos(angle);
// 		// control.steer = medcos;



// 		control.speed = SPEED_NORMAL;

//  		break;
// 	}
// 	default: {
// 		first_call = true;
// 		spion = 0;
// 		//check if vecs[0] is the middle of the screen
// 		/* Following the main vector */
// 		// int8_t vecs[0]_right = vecs[0].m_x1 > (frameWidth / 2) ? -1 : 1;
// 		int8_t resx = vecs[0].m_x1 - vecs[0].m_x0;
// 		int8_t resy = vecs[0].m_y1 - vecs[0].m_y0;
// 		VectorF vecnorm = {resx/(sqrt(resy * resy + resx * resx)),resy/(sqrt(resy * resy + resx * resx))};
// 		steers[steer_index] = vecnorm.m_x0;

// end:
// 		control.speed = SPEED_NORMAL;
// 		break;
// 	}
// 	}
